import { svelte2tsx } from '../index.mjs';
import { decode } from '@jridgewell/sourcemap-codec';
import { TraceMap, originalPositionFor } from '@jridgewell/trace-mapping';

console.log("---- Inspecting lang='ts' Sourcemap Granularity Test ----");

const svelteFileName = 'test-lang-ts.svelte';
const originalSvelteContent = `
<script lang="ts">
  const greeting: string = "Hello";
  let count: number = 10;

  function displayMessage(msg: string): void {
    console.log(msg + count);
  }

  displayMessage(greeting);
</script>

<h1>Test Component</h1>
<p>{greeting} {count}</p>
`;

console.log("\nOriginal Svelte Content (test-lang-ts.svelte):");
console.log(originalSvelteContent);

try {
    const result = svelte2tsx(originalSvelteContent, {
        filename: svelteFileName,
        isTsFile: true, // Assuming we treat it as a TS context for svelte2tsx
    });

    console.log("\nGenerated TSX Code (first 300 chars):");
    console.log(result.code.substring(0, 300) + '...');

    if (!result.map) {
        console.error("\nERROR: No sourcemap generated by svelte2tsx for lang='ts' script.");
        process.exit(1);
    }

    console.log("\nSourcemap (MagicString's base map) generated by svelte2tsx:");
    // console.log(JSON.stringify(result.map, null, 2)); // Full map can be verbose

    const decodedMappings = decode(result.map.mappings);
    const tsxLines = result.code.split('\n');

    console.log("\n\n--- Decoded Mapping Analysis for Script Content ---");
    let foundScriptMapping = false;

    // Heuristics to find where the TSX script content might be
    // This will vary based on svelte2tsx output structure.
    // Looking for lines that likely contain our original TS.
    const scriptContentNeedles = [
        'const greeting: string = "Hello";',
        'let count: number = 10;',
        'function displayMessage(msg: string): void',
        'console.log(msg + count);',
        'displayMessage(greeting);'
    ];

    decodedMappings.forEach((lineSegments, generatedLineIndex_0based) => {
        if (!lineSegments) return;

        const generatedLineText = tsxLines[generatedLineIndex_0based] || "";

        // Check if this generated line contains any of our needles
        let lineContainsNeedle = false;
        for (const needle of scriptContentNeedles) {
            if (generatedLineText.includes(needle)) {
                lineContainsNeedle = true;
                break;
            }
        }
        if (!lineContainsNeedle && !generatedLineText.trim().startsWith("/*")) { // Also check non-marker lines within typical script blocks
             // Crude check to skip template if it's obvious
            if (generatedLineText.includes("svelteHTML.createElement")) return;
        }


        lineSegments.forEach(segment => {
            if (segment.length < 4) return; // Needs at least generatedCol, sourceFileIndex, sourceLine, sourceCol

            const generatedCol_0based = segment[0];
            const sourceFileIndex = segment[1];
            const originalLine_0based = segment[2];
            const originalCol_0based = segment[3];
            const nameIndex = segment.length === 5 ? segment[4] : undefined;

            const sourceFileName = result.map.sources && result.map.sources[sourceFileIndex];

            // We are interested in mappings that originate from our Svelte file and are likely part of the script
            if (sourceFileName === svelteFileName) {
                 // Attempt to only log segments that are clearly from the script content
                 // This is a heuristic: if the generated line contains our code, log its segments.
                if (lineContainsNeedle || (generatedLineText.includes("const ") || generatedLineText.includes("let ") || generatedLineText.includes("function "))) {
                    foundScriptMapping = true;
                    console.log(
                        `TSX L${generatedLineIndex_0based + 1}C${generatedCol_0based} (text: "${generatedLineText.trim()}") ` +
                        `-> Svelte L${originalLine_0based + 1}C${originalCol_0based} ` +
                        `(Source: ${sourceFileName}${nameIndex !== undefined ? ", Name: " + (result.map.names[nameIndex]) : ""})`
                    );
                }
            }
        });
    });

    if (!foundScriptMapping) {
        console.warn("\nWARN: Could not find specific mappings for the script content. The heuristics might need adjustment or the map is very coarse.");
        console.log("This might indicate that all script content maps to a single point (e.g., the script tag itself).");
        // Log a few initial lines of decoded mappings to see general structure
        console.log("\nFirst 5 lines of decoded mappings (all sources):");
        for(let i = 0; i < Math.min(5, decodedMappings.length); i++) {
            if (!decodedMappings[i]) continue;
            decodedMappings[i].forEach(segment => {
                 if (segment.length < 4) return;
                 const sourceFileIndex = segment[1];
                 const sourceFileName = result.map.sources && result.map.sources[sourceFileIndex];
                 console.log(
                    `TSX L${i + 1}C${segment[0]} -> Svelte L${segment[2] + 1}C${segment[3]} (Source: ${sourceFileName})`
                 );
            });
        }
    }

} catch (e) {
    console.error("\nError during svelte2tsx processing or analysis:", e);
}

console.log("\n---- Test Completed ----"); 