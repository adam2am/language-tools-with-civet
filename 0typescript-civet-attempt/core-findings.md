# Core Findings: Civet Source Map Generation & Preprocessor Integration

This document summarizes the investigation into enabling source maps for Civet code when used with `svelte-preprocess-with-civet`.

# Civet Preprocessor Findings & Current+Further Steps

## Current Status & Next Milestone (As of Test Run Confirming V3 Maps & lang Attribute Change)

**`svelte-preprocess-with-civet` is now confirmed to generate V3 source maps AND correctly output `<script lang="ts">` for Civet blocks.**

*   **Key Improvement & Validation:** The transformer in `svelte-preprocess-with-civet/src/transformers/civet.ts` was updated to:
    *   Consistently pass `{ sync: true, js: false, sourceMap: true }` (among other options) to `@danielx/civet` when the user requests source maps.
    *   This results in `@danielx/civet` returning an object `{ code: "compiled TS", sourceMap: <CivetSourceMapInstance> }`.
    *   Crucially, the transformer calls `civetResult.sourceMap.json(filename, outputFilename)` on the Civet `SourceMap` instance, converting Civet's internal map into a **standard V3 source map object**.
    *   **NEW:** If the input script was `lang="civet"`, the transformer now wraps the compiled TypeScript code with `<script lang="ts">` and `</script>`.
    *   The preprocessor returns `{ code: "<script lang=\"ts\">compiled TS</script>", map: <V3MapObject> }`.
*   **Successful Test Run:** The `testPreProcTest.mjs` script (configured with `{ civet: { sourceMap: true } }`) was executed and its output confirmed:
    *   No JSON parsing errors.
    *   `result.code` contained TypeScript wrapped in `<script lang="ts">`.
    *   `result.map` was a **V3 source map object**, validated by checking for standard keys like `version` (which was 3), `sources`, and `mappings`.

**Next Milestone: Downstream Consumption of V3 Source Map**

*   **Main Idea, Aim:** Verify that the V3 source map generated by `svelte-preprocess-with-civet` can be correctly consumed and chained by downstream tools, primarily `svelte2tsx` and the Svelte Language Server / TypeScript Language Service.
*   **Testing Focus:**
    *   Ensure `SvelteDocument.ts` (or equivalent in the language server) correctly ingests the `map` object from the preprocessor.
    *   Confirm that `DocumentSnapshot.ts` can chain this (Civet -> TS) map with the map generated by `svelte2tsx` (TS -> TSX).
    *   Test end-to-end IDE features: hover, go-to-definition, and diagnostics, ensuring they map accurately back to the original Civet code in `.svelte` files.
*   **End-to-End Chain Test:** The `testChainSourceMap.mjs` script in `packages/language-server` successfully chained the Civet→TS (Map_A) and TS→TSX (Map_B) source maps, mapping a sample `foo := "bar";` reference back to the original Civet source (line 1, column 12).

## Verified End-to-End Source Map Chaining

*   The new unit test `packages/language-server/test/civet-chain.test.ts` runs an end-to-end Civet→TS→TSX chain within `SvelteDocumentSnapshot` and `ConsumerDocumentMapper`.
*   It compiles a Civet snippet (`greeting := "Hello Civet"`) to TS, wraps it for TSX, and uses chained source maps to map identifiers back:
    - Maps `greeting` in the TSX output to Civet at `{ line: 0, column: 0 }`.
    - Maps `console.log(greeting)` back to Civet at `{ line: 1, column: 0 }`.
*   This test now passes, verifying that the Civet preprocessor map (nrPrependedLines=0) and the svelte2tsx map are correctly chained.

## Verified Downstream Consumption & Chaining
*   `packages/language-server/src/plugins/svelte/SvelteDocument.ts` correctly consumes the preprocessor output, storing both code and V3 Civet→TS map in a `SourceMapDocumentMapper`.
*   `packages/language-server/src/plugins/typescript/DocumentSnapshot.ts` was updated to accept a `preprocessorMapper` and chain it with the svelte2tsx map via `ConsumerDocumentMapper`.
*   `ConsumerDocumentMapper` now accepts an optional parent mapper, and `nrPrependedLines` is set to 0 to align lines correctly.
*   All original plain-Svelte tests still pass unchanged, since chaining only activates when a preprocessor map is provided.
*   The dedicated `civet-chain.test.ts` confirms mapping behavior without affecting existing workflows.

## Read-only milestones bellow after being written (freshest=up, historically=down):
[9]
Looking at civet-diagnostics.spec.ts, the key part is how DocumentManager and LSAndTSDocResolver are set up. These components handle the preprocessing implicitly when a Svelte document with a Civet script tag is opened or processed.


[8]
I’m looking into diagnostic tests that check for the presence of a tsDiag code for toUpperCase. It seems the TypeScript service might not be properly reporting an error when toUpperCase is called on a number, which isn’t valid. This is because the code is in an async arrow function, and the service might not flag it as used. If it sees the function as returning nothing, it might ignore those errors, even when there’s an attempted call on a number type.
|
It looks like doDiagnostics isn’t affecting getDiagnostics. The diagnostics mapping occurs after calling provider.getDiagnostics, but exceptions may not be thrown unless mapping fails. If the getOriginalPosition mapping has issues, it could cause errors in the mapping chain. Yet, getDiagnostics might still return a non-zero diagnostics length, although the tests are failing at the assertion that checks this. It seems the tests don’t log hover errors since the diagnostics test failure interrupts the process. Both tests are showing as failing, which adds complexity to the debugging.


[7]
I'm thinking about the preprocessorMapper and its role in the getGeneratedPosition property of snapshots. Maybe it's not really needed after all. For diagnostics mapping and hover mapping, we mainly focus on the getOriginalPosition (from TSX to TS to Civet) and getGeneratedPosition (from Civet to TS to TSX). 
    => So, the resolution would be to adjust the ConsumerDocumentMapper.getOriginalPosition in the plugin to change the mapping order. Instead of the default, I should call mapping via this.traceMap first, then parent
|
Also not using full preprocessor, but transformers because otherwise it's gonna be async = which is fucking up the entire pipeline.

    I’ve made two fixes:
- In DocumentMapper.ts, I reversed the original‐position mapping so it first unwinds the Svelte→TSX map, then the Civet→TS map. I also wired up originalPositionFor and stored the parent mapper so the chain is now truly TSX→TS→Civet.
|
- In DocumentSnapshot.ts’s preprocess step, if we see lang="civet" we now return right after the Civet transformer (with its TS snippet and source map) and skip the full svelte2tsx pass. That way we drive diagnostics and hover directly against the TS snippet (where the type‐error and hover info live) and map back via the preprocessor map.


[6]
### Verified: End-to-End Source Map Chaining with `testChainSourceMap.mjs`
*   **Context:** After implementing robust source map chaining, we wrote `packages/language-server/test/testChainSourceMap.mjs` to validate the chain.
*   **Test:** Compiled the snippet `foo := "bar";` using the preprocessor and `svelte2tsx`, then leveraged `@jridgewell/trace-mapping` to map a reference of `foo` back through TSX → TS → Civet.
*   **Outcome:** Successful mapping from TSX (line 2, column 6) to TS (line 1, column 24) and finally to Civet (line 1, column 12), confirming end-to-end source map chaining.


[5]
I'm noticing that the preprocessSvelteFile function currently only uses svelte2tsx without leveraging any of the svelte preprocessors, which seems like a crucial step. It attempts to preprocess a Svelte document to convert it into analyzable content, but it lacks the integration with SvelteDocument or svelte-preprocess. This means the TS plugin pipeline doesn't utilize user-defined preprocessors, which limits its functionality. To make it work, the function should call either SvelteDocument.getTranspiled or 


[4]
### Verified: `SvelteDocument.ts` Correctly Consumes Preprocessor Output (Code & Map)

*   **Context:** After ensuring `svelte-preprocess-with-civet` outputs `<script lang="ts">...</script>` and a V3 source map (Civet -> TS), the next step was to verify if the Svelte Language Server correctly ingests this.
*   **Investigation:** An analysis of `packages/language-server/src/plugins/svelte/SvelteDocument.ts` (specifically the `TranspiledSvelteDocument.create` method and its usage) was performed.
*   **Findings:**
    *   `SvelteDocument.ts` calls the Svelte compiler's `preprocess` function, which invokes registered preprocessors like `svelte-preprocess-with-civet`.
    *   The result, `preprocessed`, contains `preprocessed.code` (which will be our `<script lang="ts">...</script>`) and `preprocessed.map` (our Civet -> TS V3 map).
    *   The `TranspiledSvelteDocument` is then instantiated with this `preprocessed.code`.
    *   Crucially, if `preprocessed.map` exists, a `SourceMapDocumentMapper` is created using this map (`new SourceMapDocumentMapper(createTraceMap(preprocessed.map), ...)`).
    *   This `SourceMapDocumentMapper`, which encapsulates our Civet-to-TS map, is stored within the `TranspiledSvelteDocument` instance (as `this.mapper`).
*   **Conclusion:** `SvelteDocument.ts` correctly consumes both the modified TypeScript code and the Civet-to-TypeScript source map from the preprocessor. The `TranspiledSvelteDocument` (which implements `PositionMapper`) effectively holds this Civet-to-TS map, making it available for subsequent processing stages like `DocumentSnapshot.ts`.


[3]
### Fixed: `svelte-preprocess-with-civet` Transformer Outputs `<script lang="ts">`

*   **Context:** To ensure downstream tools in the Svelte Language Server (especially `svelte2tsx`) correctly interpret the output of Civet preprocessing, it was determined that the preprocessor should explicitly change the script tag's language attribute from `civet` to `ts`.
*   **Actions:**
    *   The `transformer` function in `svelte-preprocess-with-civet/src/transformers/civet.ts` was modified to accept the script `attributes` as a parameter.
    *   Logic was added to this transformer: if `attributes.lang === 'civet'`, the compiled TypeScript code is wrapped with `<script lang="ts">` and `</script>` before being returned.
    *   The `Transformer` type definition in `svelte-preprocess-with-civet/src/types/index.ts` was confirmed to already support passing `attributes`.
    *   The calling code in `svelte-preprocess-with-civet/src/autoProcess.ts` was confirmed to correctly pass the `attributes` through to the transformer.
*   **Outcome & Validation:**
    *   The `testPreProcTest.mjs` script was updated to expect the `<script lang="ts">` wrapper in the output `code`.
    *   Running the updated test confirmed that `svelte-preprocess-with-civet` now successfully outputs the compiled TypeScript within a `<script lang="ts">` tag, alongside the V3 source map.
    *   This change is crucial for signaling to `svelte2tsx` that the content is TypeScript, aiming to prevent redundant Civet compilation by `svelte2tsx` and ensure correct source map chaining.

[2] 
### Fixed: `svelte-preprocess-with-civet` Adopts Civet's Object-based Source Maps to a V3 out

*   **Context:** Following the `SyntaxError` with `JSON.parse()` and insights into `@danielx/civet`'s ability to return a map object, `svelte-preprocess-with-civet` was updated.
*   **Thoughts:** The map object from `@danielx/civet` (keys observed: `data, source, renderMappings, json, updateSourceMap`) is **not standard V3 SourceMap format**.
*   **Actions:** Investigate this format. Determine if it can be converted to V3 or used directly by `svelte2tsx` / TypeScript Language Service. These tools typically expect V3.
*   **Modification:** The transformer in `svelte-preprocess-with-civet/src/transformers/civet.ts` was modified:
    *   It began passing `{ sync: true, js: false }` to `@danielx/civet` generally.
    *   When source maps were requested by the user (e.g., `sveltePreprocess({ civet: { sourceMap: true } })`), it specifically instructed `@danielx/civet` to return a map object by including `sourceMap: true` in its compilation options.
    *   `@danielx/civet` would then return an object like `{ code: "...", sourceMap: { ...mapObject... } }`.
    *   The transformer was updated to use this structure, returning `{ code: civetResult.code, map: civetResult.sourceMap }` to Svelte.
    *   The `Options.Civet` type definition (in `svelte-preprocess-with-civet-Repo/src/types/options.ts`) was also augmented with `inlineMap?: boolean;` to reflect compiler option capabilities.
*   **Outcome & Validation:**
    *   The `SyntaxError: Unexpected token o in JSON` was resolved.
    *   Test runs (e.g., with `testPreProcTest.mjs` configured for source maps) confirmed that `result.code` was clean TypeScript, and `result.map` now contained the raw map object directly from Civet.

### Discovery: Civet's Native Source Map Object is Non-Standard

*   **Observation:** Upon successfully retrieving the source map object from `@danielx/civet` via `svelte-preprocess-with-civet`, further inspection revealed its structure.
*   **Format:** The map object (with keys like `data, source, renderMappings, json, updateSourceMap`) was identified as **not conforming to the standard V3 SourceMap format** commonly expected by downstream tools like `svelte2tsx` and the TypeScript Language Service.
*   **Implication:** This new challenge meant this custom Civet map object would need conversion to V3 or a method for downstream tools to consume it directly before the V3 map generation (described in the current status section) was achieved.




[1]
### Initial Behaviors of `svelte-preprocess-with-civet`

*   **State+question:** Using `sourceMap: true` with `svelte-preprocess-with-civet` caused a `SyntaxError: Unexpected token o in JSON at position 1`.
*   **Reason:** The preprocessor was incorrectly trying to `JSON.parse()` the output from `@danielx/civet` when source maps were enabled, regardless of the actual output structure.

### `@danielx/civet` Source Map Generation Insights

Investigation revealed how `Civet.compile()` behaves with different options:

1.  **Preferred Method for Synchronous Code + Map Object:**
    *   **Options:** `{ sourceMap: true, sync: true, js: false }`
    *   **Returns:** An object: `{ code: "compiled TS", sourceMap: { ...mapData... } }`.
    *   **Significance:** This became the target for `svelte-preprocess-with-civet`.

2.  **Synchronous Code + Inline String Map:**
    *   **Options:** `{ inlineMap: true, sync: true, js: false }`
    *   **Returns:** A string: `"compiled TS code... //# sourceMappingURL=..."`.
    *   **Significance:** A viable, but less direct, way to get maps. Would require parsing the inline comment.

3.  **Asynchronous Code + Inline String Map:**
    *   **Options:** `await Civet.compile(civetCode, { inlineMap: true, js: false })`
    *   **Returns:** A string: `"compiled TS code... //# sourceMappingURL=..."`.

4.  **Incorrect Synchronous Attempts (Resulting in Empty Object `{}` from Civet):**
    *   `{ sourceMap: true, js: false }` (without `sync: true`)
    *   `{ inlineMap: true, js: false }` (without `sync: true`)

### Intermediate Test of `svelte-preprocess-with-civet` (Before Final Fix)

*   **Scenario:** Configured with `{ civet: { inlineMap: true, sync: true } }`.
*   **Result:**
    *   JSON error resolved (as Civet returned a string).
    *   `result.code` contained TS + the inline map comment.
    *   `result.map` was undefined (preprocessor didn't parse the inline map).
*   **Learning:** Confirmed the preprocessor needed logic to handle Civet's output string if inline maps were used, but also highlighted the need for a more direct object-based map if possible.





















